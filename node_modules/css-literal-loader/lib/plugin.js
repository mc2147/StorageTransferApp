"use strict";

exports.__esModule = true;
exports.default = plugin;

var _fsExtra = require("fs-extra");

var _kebabCase = _interopRequireDefault(require("lodash/kebabCase"));

var _path = require("path");

var t = _interopRequireWildcard(require("@babel/types"));

var _template = _interopRequireDefault(require("@babel/template"));

var _generator = _interopRequireDefault(require("@babel/generator"));

var _commonTags = require("common-tags");

var _get = _interopRequireDefault(require("lodash/get"));

var _camelCase = _interopRequireDefault(require("lodash/camelCase"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const buildImport = (0, _template.default)('require(FILENAME);');
const buildComponent = (0, _template.default)(`styled(TAGNAME, DISPLAYNAME, IMPORT, INTERPOLATION)`);
const STYLES = Symbol('CSSLiteralLoader');
/**
 * Build a logical expression returning a class, trying both the
 * kebab and camel case names: `s['fooBar'] || s['foo-bar']
 *
 * @param {String} className
 */

const buildStyleExpression = className => t.logicalExpression('||', t.memberExpression(t.identifier('s'), t.StringLiteral((0, _camelCase.default)(className.slice(1))), // remove the `.`
true), t.memberExpression(t.identifier('s'), t.StringLiteral(className.slice(1)), // remove the `.`
true));

function getIdentifier(path) {
  const parent = path.findParent(p => p.isVariableDeclarator());
  return parent && t.isIdentifier(parent.node.id) ? parent.node.id.name : '';
}

function wrapInClass(className, value, hoistImports) {
  const imports = [];

  if (hoistImports) {
    let match;
    const matcher = /@import.*?(?:$|;)/g; // eslint-disable-next-line

    while (match = matcher.exec(value)) imports.push(match[0]);

    value = value.replace(matcher, '');
  }

  let val = `${className} {\n${value}\n}`;
  if (imports.length) val = `${imports.join('\n')}\n${val}`;
  return val;
}

function createFileName(hostFile, {
  extension = '.css'
}, id) {
  const base = (0, _path.basename)(hostFile, (0, _path.extname)(hostFile));
  return (0, _path.join)((0, _path.dirname)(hostFile), `${base}-${id}${extension}`);
}

function isTag(path, tagName, allowGlobal = false) {
  return path.get('tag.name').node === tagName && (path.get('tag').referencesImport('css-literal-loader/styled') || allowGlobal && path.scope.hasGlobal(tagName));
}

function plugin() {
  function evaluate(path) {
    const {
      confident,
      value
    } = path.evaluate();

    if (!confident) {
      throw path.buildCodeFrameError('Could not evaluate css. Inline css must be statically analyzable');
    }

    return value;
  }

  function createStyleNode(path, {
    opts,
    file
  }, identifier) {
    const {
      start,
      end
    } = path.node;
    const style = {
      start,
      end
    };
    const getFileName = opts.getFileName || createFileName;
    const hostFile = file.opts.filename;
    style.path = getFileName(hostFile, opts, identifier);
    let filename = (0, _path.relative)((0, _path.dirname)(hostFile), style.path);

    if (!filename.startsWith('.')) {
      filename = `./${filename}`;
    }

    style.filename = filename;
    style.identifier = identifier;
    return style;
  }

  function extractNestedClasses(path, className, cssState, hoistImport) {
    const classNodes = [];
    const quasiPath = path.get('quasi');
    quasiPath.get('expressions').forEach(exprPath => {
      if (!t.isArrowFunctionExpression(exprPath.node)) return;
      exprPath.traverse({
        TaggedTemplateExpression(innerPath) {
          if (!isTag(innerPath, 'css')) return;
          const innerClass = `${className}-variant-${cssState.id++}`;
          const [classNode] = extractNestedClasses(innerPath, innerClass);
          const {
            node
          } = exprPath;
          exprPath.remove();
          innerPath.replaceWith(buildStyleExpression(innerClass));
          classNodes.push({ ...classNode,
            node
          });
        }

      });
    });
    return [{
      value: wrapInClass(className, evaluate(quasiPath), hoistImport),
      className
    }, ...classNodes];
  }

  function buildStyleRequire(path, state) {
    const {
      styles
    } = state.file.get(STYLES);
    const quasiPath = path.get('quasi');
    const style = createStyleNode(path, state, getIdentifier(path));
    style.value = evaluate(quasiPath);
    style.code = `require('${style.filename}')`;
    styles.add(style);
    return buildImport({
      FILENAME: t.StringLiteral(style.filename)
    }); // eslint-disable-line new-cap
  }

  function buildStyledComponent(path, state) {
    const cssState = state.file.get(STYLES);
    const tagName = (0, _get.default)(path.get('tag'), 'node.arguments[0]');
    const displayName = getIdentifier(path) || tagName.value;
    const className = `.${(0, _kebabCase.default)(displayName)}`;
    const classNodes = extractNestedClasses(path, className, cssState, true);
    const style = createStyleNode(path, state, displayName);
    style.tagName = t.isStringLiteral(tagName) ? `"${tagName.value}"` : tagName;
    style.value = classNodes.map(f => f.value).join('\n');
    let interpolations = classNodes.map(v => v.node).filter(Boolean);
    interpolations = t.ArrowFunctionExpression([t.Identifier('s')], t.ArrayExpression([buildStyleExpression(className), ...interpolations]));
    const runtimeNode = buildComponent({
      TAGNAME: tagName,
      DISPLAYNAME: t.stringLiteral(displayName),
      IMPORT: buildImport({
        FILENAME: t.StringLiteral(style.filename)
      }).expression,
      INTERPOLATION: interpolations
    });
    if (state.opts.generateInterpolations) style.code = (0, _generator.default)(runtimeNode).code;
    cssState.styles.add(style);
    return runtimeNode;
  }

  return {
    pre(file) {
      if (!file.has(STYLES)) {
        file.set(STYLES, {
          id: 0,
          styles: new Set()
        });
      }
    },

    post(file) {
      const {
        opts
      } = this;
      let {
        styles
      } = file.get(STYLES);
      styles = Array.from(styles.values());
      file.metadata['css-literal-loader'] = {
        styles
      };

      if (opts.writeFiles !== false) {
        styles.forEach(({
          path,
          value
        }) => {
          (0, _fsExtra.outputFileSync)(path, (0, _commonTags.stripIndent)([value]));
        });
      }
    },

    visitor: {
      TaggedTemplateExpression(path, state) {
        const {
          tagName = 'css',
          allowGlobal = true
        } = state.opts;
        const {
          node
        } = path;

        if (t.isCallExpression(node.tag) && path.get('tag.callee').referencesImport('css-literal-loader/styled')) {
          path.replaceWith(buildStyledComponent(path, state));
          path.addComment('leading', '#__PURE__');
        } else if (isTag(path, tagName, allowGlobal)) {
          path.replaceWith(buildStyleRequire(path, state));
          path.addComment('leading', '#__PURE__');
        }
      }

    }
  };
}