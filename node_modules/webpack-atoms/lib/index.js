"use strict";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

const path = require('path');

const autoprefixer = require('autoprefixer');

const flexbugs = require('postcss-flexbugs-fixes');

const HtmlWebpackPlugin = require('html-webpack-plugin');

const UglifyPlugin = require('uglifyjs-webpack-plugin');

const MiniCssExtractPlugin = require('mini-css-extract-plugin');

const webpack = require('webpack');

const builtinPlugins = require('./plugins');

const statsConfig = require('./stats');

let VENDOR_MODULE_REGEX = /node_modules/;
let DEFAULT_BROWSERS = ['> 1%', 'Firefox ESR', 'not ie < 9'];

function createAtoms(options) {
  let {
    babelConfig = {},
    assetRelativeRoot = '',
    env = process.env.NODE_ENV,
    vendorRegex = VENDOR_MODULE_REGEX,
    disableMiniExtractInDev = true,
    browsers: supportedBrowsers = DEFAULT_BROWSERS
  } = options || {};

  const makeExternalOnly = original => (options = {}) => {
    let rule = original(options);
    rule.include = vendorRegex;
    return rule;
  };

  const makeInternalOnly = original => (options = {}) => {
    let rule = original(options);
    rule.exclude = vendorRegex;
    return rule;
  };

  const makeExtractLoaders = ({
    extract
  } = {}, config) => [loaders.miniCssExtract({
    fallback: config.fallback,
    disable: extract == undefined ? extract : !extract
  }), ...config.use];

  const PRODUCTION = env === 'production';
  let ident = 0;
  /**
   * Loaders
   */

  const loaders = {
    json: () => ({
      loader: require.resolve('json-loader')
    }),
    yaml: () => ({
      loader: require.resolve('yaml-loader')
    }),
    null: () => ({
      loader: require.resolve('null-loader')
    }),
    raw: () => ({
      loader: require.resolve('raw-loader')
    }),
    style: () => ({
      loader: require.resolve('style-loader')
    }),
    miniCssExtract: (_ref) => {
      let {
        disable = !PRODUCTION && disableMiniExtractInDev,
        fallback
      } = _ref,
          options = _objectWithoutProperties(_ref, ["disable", "fallback"]);

      return disable ? fallback || loaders.style() : {
        loader: MiniCssExtractPlugin.loader,
        options
      };
    },
    css: (options = {}) => ({
      loader: require.resolve('css-loader'),
      options: _objectSpread({
        minimize: PRODUCTION,
        sourceMap: !PRODUCTION,
        camelCase: 'dashesOnly',
        // https://github.com/webpack-contrib/css-loader/issues/406
        localIdentName: '[name]--[local]--[hash:base64:5]'
      }, options)
    }),
    cssLiteral: (options = {}) => ({
      options,
      loader: require.resolve('css-literal-loader')
    }),
    postcss: (options = {}) => {
      let {
        plugins,
        browsers = supportedBrowsers
      } = options,
          postcssOpts = _objectWithoutProperties(options, ["plugins", "browsers"]);

      return {
        loader: require.resolve('postcss-loader'),
        options: _objectSpread({
          ident: `postcss-${++ident}`,
          plugins: loader => {
            plugins = (typeof plugins === `function` ? plugins(loader) : plugins) || [];
            return [flexbugs, autoprefixer({
              browsers,
              flexbox: `no-2009`
            }), ...plugins];
          }
        }, postcssOpts)
      };
    },
    less: (options = {}) => ({
      options,
      loader: require.resolve('less-loader')
    }),
    sass: (options = {}) => ({
      options,
      loader: require.resolve('sass-loader')
    }),
    file: (options = {}) => ({
      loader: require.resolve('url-loader'),
      options: _objectSpread({
        name: `${assetRelativeRoot}[name]-[hash].[ext]`
      }, options)
    }),
    url: (options = {}) => ({
      loader: require.resolve('url-loader'),
      options: _objectSpread({
        limit: 10000,
        name: `${assetRelativeRoot}[name]-[hash].[ext]`
      }, options)
    }),
    js: (options = babelConfig) => ({
      options,
      loader: require.resolve('babel-loader')
    }),
    imports: (options = {}) => ({
      options,
      loader: require.resolve('imports-loader')
    }),
    exports: (options = {}) => ({
      options,
      loader: require.resolve('exports-loader')
    })
    /**
     * Rules
     */

  };
  const rules = {};
  /**
   * Javascript loader via babel, excludes node_modules
   */

  {
    let js = (options = {}) => ({
      test: /\.jsx?$/,
      exclude: vendorRegex,
      use: [loaders.js(options)]
    });

    js.inlineCss = (options = {}) => {
      let {
        tagName,
        extension
      } = options,
          rest = _objectWithoutProperties(options, ["tagName", "extension"]);

      let rule = js(rest);
      rule.use.push(loaders.cssLiteral({
        tagName,
        extension
      }));
      return rule;
    };

    rules.js = js;
  }

  rules.yaml = () => ({
    test: /\.ya?ml/,
    use: [loaders.json(), loaders.yaml()]
  });
  /**
   * Font loader
   */


  rules.fonts = () => ({
    use: [loaders.url()],
    test: /\.(eot|otf|ttf|woff(2)?)(\?.*)?$/
  });
  /**
   * Loads image assets, inlines images via a data URI if they are below
   * the size threshold
   */


  rules.images = () => ({
    use: [loaders.url()],
    test: /\.(ico|svg|jpg|jpeg|png|gif|webp)(\?.*)?$/
  });
  /**
   * Loads audio or video assets
   */


  rules.audioVideo = () => ({
    use: [loaders.file()],
    test: /\.(mp4|webm|wav|mp3|m4a|aac|oga|flac)$/
  });
  /**
   * A catch-all rule for everything that isn't js, json, or html.
   * Should only be used in the context of a webpack `oneOf` rule as a fallback
   * (see rules.assets())
   */


  rules.files = () => ({
    // Exclude `js` files to keep "css" loader working as it injects
    // it's runtime that would otherwise processed through "file" loader.
    // Also exclude `html` and `json` extensions so they get processed
    // by webpacks internal loaders.
    exclude: [/\.jsx?$/, /\.html$/, /\.json$/],
    use: [loaders.file()]
  });
  /**
   * CSS style loader.
   */


  {
    const css = (_ref2 = {}) => {
      let {
        browsers
      } = _ref2,
          options = _objectWithoutProperties(_ref2, ["browsers"]);

      return {
        test: /\.css$/,
        use: makeExtractLoaders(options, {
          fallback: loaders.style(),
          use: [loaders.css(_objectSpread({}, options, {
            importLoaders: 1
          })), loaders.postcss({
            browsers
          })]
        })
      };
    };
    /**
     * CSS style loader, _excludes_ node_modules.
     */


    css.internal = makeInternalOnly(css);
    css.external = makeExternalOnly(css);

    css.modules = options => _objectSpread({}, css(_objectSpread({}, options, {
      modules: true
    })), {
      test: /\.module\.css$/
    });

    rules.css = css;
  }
  /**
   * PostCSS loader.
   */

  {
    const postcss = (_ref3 = {}) => {
      let {
        modules
      } = _ref3,
          opts = _objectWithoutProperties(_ref3, ["modules"]);

      return {
        test: /\.css$/,
        use: makeExtractLoaders(opts, {
          fallback: loaders.style,
          use: [loaders.css({
            importLoaders: 1,
            modules
          }), loaders.postcss(opts)]
        })
      };
    };
    /**
     * PostCSS loader, _excludes_ node_modules.
     */


    postcss.internal = makeInternalOnly(postcss);
    postcss.external = makeExternalOnly(postcss);

    postcss.modules = options => _objectSpread({}, postcss(_objectSpread({}, options, {
      modules: true
    })), {
      test: /\.module\.css$/
    });

    rules.postcss = postcss;
  }
  /**
   * Less style loader.
   */

  {
    const less = (_ref4 = {}) => {
      let {
        modules,
        browsers
      } = _ref4,
          options = _objectWithoutProperties(_ref4, ["modules", "browsers"]);

      return {
        test: /\.less$/,
        use: makeExtractLoaders(options, {
          fallback: loaders.style(),
          use: [loaders.css({
            importLoaders: 1,
            modules
          }), loaders.postcss({
            browsers
          }), loaders.less(options)]
        })
      };
    };
    /**
     * Less style loader, _excludes_ node_modules.
     */


    less.internal = makeInternalOnly(less);
    less.external = makeExternalOnly(less);

    less.modules = options => _objectSpread({}, less(_objectSpread({}, options, {
      modules: true
    })), {
      test: /\.module\.less$/
    });

    rules.less = less;
  }
  /**
   * SASS style loader, excludes node_modules.
   */

  {
    const sass = (_ref5 = {}) => {
      let {
        browsers,
        modules
      } = _ref5,
          options = _objectWithoutProperties(_ref5, ["browsers", "modules"]);

      return {
        test: /\.s(a|c)ss$/,
        use: makeExtractLoaders(options, {
          fallback: loaders.style(),
          use: [loaders.css({
            importLoaders: 1,
            modules
          }), loaders.postcss({
            browsers
          }), loaders.sass(options)]
        })
      };
    };
    /**
     * SCSS style loader, _excludes_ node_modules.
     */


    sass.internal = makeInternalOnly(sass);
    sass.external = makeExternalOnly(sass);

    sass.modules = options => _objectSpread({}, sass(_objectSpread({}, options, {
      modules: true
    })), {
      test: /\.module\.s(a|c)ss$/
    });

    rules.sass = sass;
  }
  /**
   * Plugins
   */

  const plugins = _objectSpread({}, builtinPlugins);
  /**
   * https://webpack.js.org/plugins/define-plugin/
   *
   * Replace tokens in code with static values. Defaults to setting NODE_ENV
   * which is used by React and other libraries to toggle development mode.
   */


  plugins.define = (defines = {}) => new webpack.DefinePlugin(_objectSpread({
    'process.env.NODE_ENV': JSON.stringify(env)
  }, defines));
  /**
   * The webpack2 shim plugin for passing options to loaders. Sets
   * the minize and debug options to `true` in production (used by various loaders)
   */


  plugins.loaderOptions = (options = {}) => new webpack.LoaderOptionsPlugin({
    options,
    minimize: PRODUCTION,
    debug: !PRODUCTION
  });
  /**
   * Minify javascript code without regard for IE8. Attempts
   * to parallelize the work to save time. Generally only add in Production
   */


  plugins.uglify = (_ref6 = {}) => {
    let {
      uglifyOptions
    } = _ref6,
        options = _objectWithoutProperties(_ref6, ["uglifyOptions"]);

    return new UglifyPlugin(_objectSpread({
      cache: true,
      parallel: true,
      sourceMap: true,
      uglifyOptions: _objectSpread({
        compress: {
          drop_console: true
        },
        ie8: false
      }, uglifyOptions)
    }, options));
  };
  /**
   * Extracts css requires into a single file;
   * includes some reasonable defaults
   */


  plugins.extractCss = options => new MiniCssExtractPlugin(_objectSpread({
    filename: '[name]-[contenthash].css'
  }, options));
  /**
   * Generates an html file that includes the output bundles.
   * Sepecify a `title` option to set the page title.
   */


  plugins.html = opts => new HtmlWebpackPlugin(_objectSpread({
    inject: true,
    template: path.join(__dirname, '../assets/index.html')
  }, opts));

  plugins.moment = () => new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/);

  const stats = {
    none: statsConfig,
    minimal: _objectSpread({}, statsConfig, {
      errors: true,
      errorDetails: true,
      assets: true,
      chunks: true,
      colors: true,
      performance: true,
      timings: true,
      warnings: true
    })
  };
  return {
    loaders,
    rules: rules,
    plugins: plugins,
    stats
  };
}

module.exports = _objectSpread({}, createAtoms(), {
  createAtoms
});